{
  "version": 3,
  "sources": ["../../ol/layer/BaseImage.js", "../../ol/renderer/canvas/ImageLayer.js", "../../ol/layer/Image.js", "../../ol/layer/TileProperty.js", "../../ol/layer/BaseTile.js", "../../ol/reproj/common.js", "../../ol/reproj/Tile.js", "../../ol/reproj/Triangulation.js", "../../ol/reproj.js", "../../ol/renderer/canvas/TileLayer.js", "../../ol/layer/Tile.js", "../../ol/DataTile.js", "../../ol/reproj/DataTile.js", "../../ol/resolution.js"],
  "sourcesContent": ["/**\n * @module ol/layer/BaseImage\n */\nimport Layer from './Layer.js';\n\n/**\n * @template {import(\"../source/Image.js\").default} ImageSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {ImageSourceType} [source] Source for this layer.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * Server-rendered images that are available for arbitrary extents and\n * resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Image.js\").default} ImageSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<ImageSourceType, RendererType>}\n * @api\n */\nclass BaseImageLayer extends Layer {\n  /**\n   * @param {Options<ImageSourceType>} [options] Layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super(options);\n  }\n}\n\nexport default BaseImageLayer;\n", "/**\n * @module ol/renderer/canvas/ImageLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageState from '../../ImageState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {\n  containsCoordinate,\n  containsExtent,\n  getHeight,\n  getIntersection,\n  getWidth,\n  intersects as intersectsExtent,\n  isEmpty,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\n\n/**\n * @classdesc\n * Canvas renderer for image layers.\n * @api\n */\nclass CanvasImageLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Image.js\").default} imageLayer Image layer.\n   */\n  constructor(imageLayer) {\n    super(imageLayer);\n\n    /**\n     * @protected\n     * @type {?import(\"../../Image.js\").default}\n     */\n    this.image_ = null;\n  }\n\n  /**\n   * @return {import('../../DataTile.js').ImageLike} Image.\n   */\n  getImage() {\n    return !this.image_ ? null : this.image_.getImage();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewResolution = viewState.resolution;\n\n    const imageSource = this.getLayer().getSource();\n\n    const hints = frameState.viewHints;\n\n    let renderedExtent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      renderedExtent = getIntersection(\n        renderedExtent,\n        fromUserExtent(layerState.extent, viewState.projection)\n      );\n    }\n\n    if (\n      !hints[ViewHint.ANIMATING] &&\n      !hints[ViewHint.INTERACTING] &&\n      !isEmpty(renderedExtent)\n    ) {\n      if (imageSource) {\n        const projection = viewState.projection;\n        const image = imageSource.getImage(\n          renderedExtent,\n          viewResolution,\n          pixelRatio,\n          projection\n        );\n        if (image) {\n          if (this.loadImage(image)) {\n            this.image_ = image;\n          } else if (image.getState() === ImageState.EMPTY) {\n            this.image_ = null;\n          }\n        }\n      } else {\n        this.image_ = null;\n      }\n    }\n\n    return !!this.image_;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const imageExtent = this.image_.getExtent();\n    const img = this.image_.getImage();\n\n    const imageMapWidth = getWidth(imageExtent);\n    const col = Math.floor(\n      img.width * ((coordinate[0] - imageExtent[0]) / imageMapWidth)\n    );\n    if (col < 0 || col >= img.width) {\n      return null;\n    }\n\n    const imageMapHeight = getHeight(imageExtent);\n    const row = Math.floor(\n      img.height * ((imageExtent[3] - coordinate[1]) / imageMapHeight)\n    );\n    if (row < 0 || row >= img.height) {\n      return null;\n    }\n\n    return this.getImageData(img, col, row);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const image = this.image_;\n    const imageExtent = image.getExtent();\n    const imageResolution = image.getResolution();\n    const [imageResolutionX, imageResolutionY] = Array.isArray(imageResolution)\n      ? imageResolution\n      : [imageResolution, imageResolution];\n    const imagePixelRatio = image.getPixelRatio();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const viewCenter = viewState.center;\n    const viewResolution = viewState.resolution;\n    const scaleX =\n      (pixelRatio * imageResolutionX) / (viewResolution * imagePixelRatio);\n    const scaleY =\n      (pixelRatio * imageResolutionY) / (viewResolution * imagePixelRatio);\n\n    const extent = frameState.extent;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n\n    const context = this.context;\n    const canvas = context.canvas;\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    // clipped rendering if layer extent is set\n    let clipped = false;\n    let render = true;\n    if (layerState.extent) {\n      const layerExtent = fromUserExtent(\n        layerState.extent,\n        viewState.projection\n      );\n      render = intersectsExtent(layerExtent, frameState.extent);\n      clipped = render && !containsExtent(layerExtent, frameState.extent);\n      if (clipped) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    const img = image.getImage();\n\n    const transform = composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      scaleX,\n      scaleY,\n      0,\n      (imagePixelRatio * (imageExtent[0] - viewCenter[0])) / imageResolutionX,\n      (imagePixelRatio * (viewCenter[1] - imageExtent[3])) / imageResolutionY\n    );\n\n    this.renderedResolution = (imageResolutionY * pixelRatio) / imagePixelRatio;\n\n    const dw = img.width * transform[0];\n    const dh = img.height * transform[3];\n\n    if (!this.getLayer().getSource().getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n    if (render && dw >= 0.5 && dh >= 0.5) {\n      const dx = transform[4];\n      const dy = transform[5];\n      const opacity = layerState.opacity;\n      let previousAlpha;\n      if (opacity !== 1) {\n        previousAlpha = context.globalAlpha;\n        context.globalAlpha = opacity;\n      }\n      context.drawImage(img, 0, 0, +img.width, +img.height, dx, dy, dw, dh);\n      if (opacity !== 1) {\n        context.globalAlpha = previousAlpha;\n      }\n    }\n    this.postRender(context, frameState);\n\n    if (clipped) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n}\n\nexport default CanvasImageLayerRenderer;\n", "/**\n * @module ol/layer/Image\n */\nimport BaseImageLayer from './BaseImage.js';\nimport CanvasImageLayerRenderer from '../renderer/canvas/ImageLayer.js';\n\n/**\n * @classdesc\n * Server-rendered images that are available for arbitrary extents and\n * resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Image.js\").default} ImageSourceType\n * @extends {BaseImageLayer<ImageSourceType, CanvasImageLayerRenderer>}\n * @api\n */\nclass ImageLayer extends BaseImageLayer {\n  /**\n   * @param {import(\"./BaseImage.js\").Options<ImageSourceType>} [options] Layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  createRenderer() {\n    return new CanvasImageLayerRenderer(this);\n  }\n\n  /**\n   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the\n   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the\n   * source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default ImageLayer;\n", "/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n", "/**\n * @module ol/layer/BaseTile\n */\nimport Layer from './Layer.js';\nimport TileProperty from './TileProperty.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Base\").BaseLayerObjectEventTypes|\n *     import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../render/EventType\").LayerRenderEventTypes, import(\"../render/Event\").default, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"./Base\").BaseLayerObjectEventTypes|\n *   import(\"./Layer.js\").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import(\"../render/EventType\").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature\n */\n\n/**\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {TileSourceType} [source] Source for this layer.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link import(\"../Map.js\").default#addLayer map.addLayer()}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @template {import(\"../renderer/Layer.js\").default} RendererType\n * @extends {Layer<TileSourceType, RendererType>}\n * @api\n */\nclass BaseTileLayer extends Layer {\n  /**\n   * @param {Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const baseOptions = Object.assign({}, options);\n\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    super(baseOptions);\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {BaseTileLayerOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {BaseTileLayerOnSignature<void>}\n     */\n    this.un;\n\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(\n      options.useInterimTilesOnError !== undefined\n        ? options.useInterimTilesOnError\n        : true\n    );\n  }\n\n  /**\n   * Return the level as number to which we will preload tiles up to.\n   * @return {number} The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  getPreload() {\n    return /** @type {number} */ (this.get(TileProperty.PRELOAD));\n  }\n\n  /**\n   * Set the level as number to which we will preload tiles up to.\n   * @param {number} preload The level to preload tiles up to.\n   * @observable\n   * @api\n   */\n  setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  }\n\n  /**\n   * Whether we use interim tiles on error.\n   * @return {boolean} Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  getUseInterimTilesOnError() {\n    return /** @type {boolean} */ (\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  }\n\n  /**\n   * Set whether we use interim tiles on error.\n   * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n   * @observable\n   * @api\n   */\n  setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  }\n\n  /**\n   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,\n   * a four element RGBA array will be returned.  For data tiles, the array length will match the\n   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.\n   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.\n   *\n   * ```js\n   * // display layer data on every pointer move\n   * map.on('pointermove', (event) => {\n   *   console.log(layer.getData(event.pixel));\n   * });\n   * ```\n   * @param {import(\"../pixel\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   * @api\n   */\n  getData(pixel) {\n    return super.getData(pixel);\n  }\n}\n\nexport default BaseTileLayer;\n", "/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;\n", "/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {releaseCanvas} from '../dom.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    options\n  ) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../ImageTile.js\").default>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent,\n        this.sourceZ_\n      );\n\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((tile) => {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach((tile) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(\n            tile,\n            EventType.CHANGE,\n            function (e) {\n              const state = tile.getState();\n              if (\n                state == TileState.LOADED ||\n                state == TileState.ERROR ||\n                state == TileState.EMPTY\n              ) {\n                unlistenByKey(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            },\n            this\n          );\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n", "/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {getTransform} from '../proj.js';\nimport {modulo} from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overall reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                getArea(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256)\n              )\n            )\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0]\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach((triangle) => {\n        if (\n          Math.max(\n            triangle.source[0][0],\n            triangle.source[1][0],\n            triangle.source[2][0]\n          ) -\n            leftBound >\n          this.sourceWorldWidth_ / 2\n        ) {\n          const newTriangle = [\n            [triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]],\n          ];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          const minX = Math.min(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0]\n          );\n          const maxX = Math.max(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0]\n          );\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n", "/**\n * @module ol/reproj\n */\nimport {\n  containsCoordinate,\n  createEmpty,\n  extend,\n  forEachCorner,\n  getCenter,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from './extent.js';\nimport {createCanvasContext2D, releaseCanvas} from './dom.js';\nimport {getPointResolution, transform} from './proj.js';\nimport {solveLinearSystem} from './math.js';\n\nlet brokenDiagonalRendering_;\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return (\n    Math.abs(data[offset * 4] - 210) > 2 ||\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\n  );\n}\n\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    const ctx = createCanvasContext2D(6, 6, canvasPool);\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    const data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ =\n      verifyBrokenDiagonalRendering(data, 0) ||\n      verifyBrokenDiagonalRendering(data, 4) ||\n      verifyBrokenDiagonalRendering(data, 8);\n    releaseCanvas(ctx);\n    canvasPool.push(ctx.canvas);\n  }\n\n  return brokenDiagonalRendering_;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(\n  sourceProj,\n  targetProj,\n  targetCenter,\n  targetResolution\n) {\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = getPointResolution(\n    targetProj,\n    targetResolution,\n    targetCenter\n  );\n\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    const compensationFactor =\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n      sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(\n  sourceProj,\n  targetProj,\n  targetExtent,\n  targetResolution\n) {\n  const targetCenter = getCenter(targetExtent);\n  let sourceResolution = calculateSourceResolution(\n    sourceProj,\n    targetProj,\n    targetCenter,\n    targetResolution\n  );\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(\n        sourceProj,\n        targetProj,\n        corner,\n        targetResolution\n      );\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n\n  return sourceResolution;\n}\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchContext.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(\n  width,\n  height,\n  pixelRatio,\n  sourceResolution,\n  sourceExtent,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  renderEdges,\n  interpolate,\n  drawSingle\n) {\n  const context = createCanvasContext2D(\n    Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height),\n    canvasPool\n  );\n\n  if (!interpolate) {\n    context.imageSmoothingEnabled = false;\n  }\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n\n  context.globalCompositeOperation = 'lighter';\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  let stitchContext;\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    const canvasWidthInUnits = getWidth(sourceDataExtent);\n    const canvasHeightInUnits = getHeight(sourceDataExtent);\n    stitchContext = createCanvasContext2D(\n      Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution),\n      Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution),\n      canvasPool\n    );\n\n    if (!interpolate) {\n      stitchContext.imageSmoothingEnabled = false;\n    }\n\n    const stitchScale = pixelRatio / sourceResolution;\n\n    sources.forEach(function (src, i, arr) {\n      const xPos = src.extent[0] - sourceDataExtent[0];\n      const yPos = -(src.extent[3] - sourceDataExtent[3]);\n      const srcWidth = getWidth(src.extent);\n      const srcHeight = getHeight(src.extent);\n\n      // This test should never fail -- but it does. Need to find a fix the upstream condition\n      if (src.image.width > 0 && src.image.height > 0) {\n        stitchContext.drawImage(\n          src.image,\n          gutter,\n          gutter,\n          src.image.width - 2 * gutter,\n          src.image.height - 2 * gutter,\n          xPos * stitchScale,\n          yPos * stitchScale,\n          srcWidth * stitchScale,\n          srcHeight * stitchScale\n        );\n      }\n    });\n  }\n  const targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0],\n      y0 = source[0][1];\n    let x1 = source[1][0],\n      y1 = source[1][1];\n    let x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    const v0 = pixelRound(\n      -(target[0][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    const v1 = pixelRound(\n      -(target[1][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    const v2 = pixelRound(\n      -(target[2][1] - targetTopLeft[1]) / targetResolution\n    );\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    const augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0],\n    ];\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n\n    if (isBrokenDiagonalRendering() || !interpolate) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      const steps = 4;\n      const ud = u0 - u1;\n      const vd = v0 - v1;\n      for (let step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(\n          u1 + pixelRound(((step + 1) * ud) / steps),\n          v1 + pixelRound((step * vd) / (steps - 1))\n        );\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(\n            u1 + pixelRound(((step + 1) * ud) / steps),\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1))\n          );\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n\n    context.clip();\n\n    context.transform(\n      affineCoefs[0],\n      affineCoefs[2],\n      affineCoefs[1],\n      affineCoefs[3],\n      u0,\n      v0\n    );\n\n    context.translate(\n      sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY\n    );\n\n    let image;\n    if (stitchContext) {\n      image = stitchContext.canvas;\n      context.scale(\n        sourceResolution / pixelRatio,\n        -sourceResolution / pixelRatio\n      );\n    } else {\n      const source = sources[0];\n      const extent = source.extent;\n      image = source.image;\n      context.scale(\n        getWidth(extent) / image.width,\n        -getHeight(extent) / image.height\n      );\n    }\n\n    context.drawImage(image, 0, 0);\n    context.restore();\n  });\n\n  if (stitchContext) {\n    releaseCanvas(stitchContext);\n    canvasPool.push(stitchContext.canvas);\n  }\n\n  if (renderEdges) {\n    context.save();\n\n    context.globalCompositeOperation = 'source-over';\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n", "/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getHeight,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  getWidth,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = source.getTile(\n        z,\n        tileCoord[1],\n        tileCoord[2],\n        pixelRatio,\n        projection\n      );\n      if (\n        !(tile instanceof ImageTile || tile instanceof ReprojTile) ||\n        (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY)\n      ) {\n        return null;\n      }\n\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0])\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1])\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection)\n      );\n\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    let extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(\n        extent,\n        fromUserExtent(layerState.extent, projection)\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource,\n      projection,\n      tilesToDrawByZ\n    );\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (\n          rotation &&\n          !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n        ) {\n          continue;\n        }\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            let inTransition = tile.inTransition(uid);\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n            if (\n              !this.newTiles_ &&\n              (inTransition || !this.renderedTiles.includes(tile))\n            ) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord,\n          tmpTileRange,\n          tmpExtent\n        );\n\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord,\n            findLoadedTiles,\n            tmpTileRange,\n            tmpExtent\n          );\n        }\n      }\n    }\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    const context = this.context;\n    const canvas = context.canvas;\n\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2\n    );\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(ascending);\n\n    let clips, clipZs, currentClip;\n    if (\n      layerState.opacity === 1 &&\n      (!this.containerReused ||\n        tileSource.getOpaque(frameState.viewState.projection))\n    ) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (\n          tilesToDraw[tileCoordKey]\n        );\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n\n        const inTransition =\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        let contextSaved = false;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                if (\n                  intersects(\n                    [x, y, x + w, y + h],\n                    [clip[0], clip[3], clip[4], clip[7]]\n                  )\n                ) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n                  context.beginPath();\n                  // counter-clockwise (outer ring) for current tile\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]);\n                  // clockwise (inner ring) for higher z tile\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(\n          tile,\n          frameState,\n          x,\n          y,\n          w,\n          h,\n          tileGutter,\n          transition\n        );\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.manageTilePyramid(\n      frameState,\n      tileSource,\n      tileGrid,\n      pixelRatio,\n      projection,\n      extent,\n      z,\n      tileLayer.getPreload()\n    );\n    this.scheduleExpireCache(frameState, tileSource);\n\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h\n    );\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(\n            frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey]\n          );\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../../Map.js\").PostRenderFunction} */ (\n          postRenderFunction\n        )\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\n   * @protected\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    tileCallback\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    const rotation = frameState.viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          frameState.viewState.center,\n          frameState.viewState.resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([\n                  tile,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\n                  tileResolution,\n                ]);\n              }\n            }\n            if (tileCallback !== undefined) {\n              tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n", "/**\n * @module ol/layer/Tile\n */\nimport BaseTileLayer from './BaseTile.js';\nimport CanvasTileLayerRenderer from '../renderer/canvas/TileLayer.js';\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import(\"../source/Tile.js\").default} TileSourceType\n * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>\n * @api\n */\nclass TileLayer extends BaseTileLayer {\n  /**\n   * @param {import(\"./BaseTile.js\").Options<TileSourceType>} [options] Tile layer options.\n   */\n  constructor(options) {\n    super(options);\n  }\n\n  createRenderer() {\n    return new CanvasTileLayerRenderer(this);\n  }\n}\n\nexport default TileLayer;\n", "/**\n * @module ol/DataTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\n\n/**\n * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike\n */\n\n/**\n * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike\n */\n\n/**\n * Data that can be used with a DataTile.\n * @typedef {ArrayLike|ImageLike} Data\n */\n\n/**\n * @param {Data} data Tile data.\n * @return {ImageLike|null} The image-like data.\n */\nexport function asImageLike(data) {\n  return data instanceof Image ||\n    data instanceof HTMLCanvasElement ||\n    data instanceof HTMLVideoElement ||\n    data instanceof ImageBitmap\n    ? data\n    : null;\n}\n\n/**\n * @param {Data} data Tile data.\n * @return {ArrayLike|null} The array-like data.\n */\nexport function asArrayLike(data) {\n  return data instanceof Uint8Array ||\n    data instanceof Uint8ClampedArray ||\n    data instanceof Float32Array ||\n    data instanceof DataView\n    ? data\n    : null;\n}\n\n/**\n * @type {CanvasRenderingContext2D|null}\n */\nlet sharedContext = null;\n\n/**\n * @param {ImageLike} image The image.\n * @return {Uint8ClampedArray} The data.\n */\nexport function toArray(image) {\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(\n      image.width,\n      image.height,\n      undefined,\n      {willReadFrequently: true}\n    );\n  }\n  const canvas = sharedContext.canvas;\n  const width = image.width;\n  if (canvas.width !== width) {\n    canvas.width = width;\n  }\n  const height = image.height;\n  if (canvas.height !== height) {\n    canvas.height = height;\n  }\n  sharedContext.clearRect(0, 0, width, height);\n  sharedContext.drawImage(image, 0, 0);\n  return sharedContext.getImageData(0, 0, width, height).data;\n}\n\n/**\n * @type {import('./size.js').Size}\n */\nconst defaultSize = [256, 256];\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,\n * the promise should not resolve until the image is loaded.\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {import('./size.js').Size} [size=[256, 256]] Tile size.\n * @api\n */\n\nclass DataTile extends Tile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    const state = TileState.IDLE;\n\n    super(options.tileCoord, state, {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    });\n\n    /**\n     * @type {function(): Promise<Data>}\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @type {Data}\n     * @private\n     */\n    this.data_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.error_ = null;\n\n    /**\n     * @type {import('./size.js').Size|null}\n     * @private\n     */\n    this.size_ = options.size || null;\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('./size.js').Size} Tile size.\n   */\n  getSize() {\n    if (this.size_) {\n      return this.size_;\n    }\n    const imageData = asImageLike(this.data_);\n    if (imageData) {\n      return [imageData.width, imageData.height];\n    }\n    return defaultSize;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {Data} Tile data.\n   * @api\n   */\n  getData() {\n    return this.data_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   * @api\n   */\n  getError() {\n    return this.error_;\n  }\n\n  /**\n   * Load not yet loaded URI.\n   * @api\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    const self = this;\n    this.loader_()\n      .then(function (data) {\n        self.data_ = data;\n        self.state = TileState.LOADED;\n        self.changed();\n      })\n      .catch(function (error) {\n        self.error_ = error;\n        self.state = TileState.ERROR;\n        self.changed();\n      });\n  }\n}\n\nexport default DataTile;\n", "/**\n * @module ol/reproj/DataTile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport DataTile, {asArrayLike, asImageLike, toArray} from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {createCanvasContext2D, releaseCanvas} from '../dom.js';\nimport {getArea, getIntersection} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../DataTile.js\").default} TileGetter\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n * @property {import(\"../proj/Projection.js\").default} targetProj Target projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n * @property {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n * @property {import(\"../tilecoord.js\").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.\n * @property {number} pixelRatio Pixel ratio.\n * @property {number} gutter Gutter of the source tiles.\n * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {number} [errorThreshold] Acceptable reprojection error (in px).\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected data tile.\n * See {@link module:ol/source/DataTile~DataTileSource}.\n *\n */\nclass ReprojDataTile extends DataTile {\n  /**\n   * @param {Options} options Tile options.\n   */\n  constructor(options) {\n    super({\n      tileCoord: options.tileCoord,\n      loader: () => Promise.resolve(new Uint8Array(4)),\n      interpolate: options.interpolate,\n      transition: options.transition,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     * @private\n     */\n    this.reprojData_ = null;\n\n    /**\n     * @type {Error}\n     * @private\n     */\n    this.reprojError_ = null;\n\n    /**\n     * @type {import('../size.js').Size}\n     * @private\n     */\n    this.reprojSize_ = undefined;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = options.sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = options.targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<DataTile>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n      this.wrappedTileCoord_\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProj = options.sourceProj;\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = this.targetTileGrid_.getResolution(\n      this.wrappedTileCoord_[0]\n    );\n\n    const targetProj = options.targetProj;\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      options.errorThreshold !== undefined\n        ? options.errorThreshold\n        : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(\n        sourceExtent,\n        this.sourceZ_\n      );\n      const getTile = options.getTileFunction;\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the tile size.\n   * @return {import('../size.js').Size} Tile size.\n   */\n  getSize() {\n    return this.reprojSize_;\n  }\n\n  /**\n   * Get the data for the tile.\n   * @return {import(\"../DataTile.js\").Data} Tile data.\n   */\n  getData() {\n    return this.reprojData_;\n  }\n\n  /**\n   * Get any loading error.\n   * @return {Error} Loading error.\n   */\n  getError() {\n    return this.reprojError_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const dataSources = [];\n    this.sourceTiles_.forEach((tile) => {\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const size = tile.getSize();\n      const gutter = this.gutter_;\n      /**\n       * @type {import(\"../DataTile.js\").ArrayLike}\n       */\n      let tileData;\n      const arrayData = asArrayLike(tile.getData());\n      if (arrayData) {\n        tileData = arrayData;\n      } else {\n        tileData = toArray(asImageLike(tile.getData()));\n      }\n      const pixelSize = [size[0] + 2 * gutter, size[1] + 2 * gutter];\n      const isFloat = tileData instanceof Float32Array;\n      const pixelCount = pixelSize[0] * pixelSize[1];\n      const DataType = isFloat ? Float32Array : Uint8Array;\n      const tileDataR = new DataType(tileData.buffer);\n      const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n      const bytesPerPixel = (bytesPerElement * tileDataR.length) / pixelCount;\n      const bytesPerRow = tileDataR.byteLength / pixelSize[1];\n      const bandCount = Math.floor(\n        bytesPerRow / bytesPerElement / pixelSize[0]\n      );\n      const packedLength = pixelCount * bandCount;\n      let packedData = tileDataR;\n      if (tileDataR.length !== packedLength) {\n        packedData = new DataType(packedLength);\n        let dataIndex = 0;\n        let rowOffset = 0;\n        const colCount = pixelSize[0] * bandCount;\n        for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\n          for (let colIndex = 0; colIndex < colCount; ++colIndex) {\n            packedData[dataIndex++] = tileDataR[rowOffset + colIndex];\n          }\n          rowOffset += bytesPerRow / bytesPerElement;\n        }\n      }\n      dataSources.push({\n        extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n        data: new Uint8Array(packedData.buffer),\n        dataType: DataType,\n        bytesPerPixel: bytesPerPixel,\n        pixelSize: pixelSize,\n      });\n    });\n    this.sourceTiles_.length = 0;\n\n    if (dataSources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const targetWidth = typeof size === 'number' ? size : size[0];\n      const targetHeight = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_\n      );\n\n      let dataR, dataU;\n\n      const bytesPerPixel = dataSources[0].bytesPerPixel;\n\n      const reprojs = Math.ceil(bytesPerPixel / 3);\n      for (let reproj = reprojs - 1; reproj >= 0; --reproj) {\n        const sources = [];\n        for (let i = 0, len = dataSources.length; i < len; ++i) {\n          const dataSource = dataSources[i];\n          const buffer = dataSource.data;\n          const pixelSize = dataSource.pixelSize;\n          const width = pixelSize[0];\n          const height = pixelSize[1];\n          const context = createCanvasContext2D(width, height, canvasPool);\n          const imageData = context.createImageData(width, height);\n          const data = imageData.data;\n          let offset = reproj * 3;\n          for (let j = 0, len = data.length; j < len; j += 4) {\n            data[j] = buffer[offset];\n            data[j + 1] = buffer[offset + 1];\n            data[j + 2] = buffer[offset + 2];\n            data[j + 3] = 255;\n            offset += bytesPerPixel;\n          }\n          context.putImageData(imageData, 0, 0);\n          sources.push({\n            extent: dataSource.extent,\n            image: context.canvas,\n          });\n        }\n\n        const canvas = renderReprojected(\n          targetWidth,\n          targetHeight,\n          this.pixelRatio_,\n          sourceResolution,\n          this.sourceTileGrid_.getExtent(),\n          targetResolution,\n          targetExtent,\n          this.triangulation_,\n          sources,\n          this.gutter_,\n          false,\n          false\n        );\n\n        for (let i = 0, len = sources.length; i < len; ++i) {\n          const canvas = sources[i].image;\n          const context = canvas.getContext('2d');\n          releaseCanvas(context);\n          canvasPool.push(context.canvas);\n        }\n\n        const context = canvas.getContext('2d');\n        const imageData = context.getImageData(\n          0,\n          0,\n          canvas.width,\n          canvas.height\n        );\n\n        releaseCanvas(context);\n        canvasPool.push(canvas);\n\n        if (!dataR) {\n          dataU = new Uint8Array(\n            bytesPerPixel * imageData.width * imageData.height\n          );\n          dataR = new dataSources[0].dataType(dataU.buffer);\n        }\n\n        const data = imageData.data;\n        let offset = reproj * 3;\n        for (let i = 0, len = data.length; i < len; i += 4) {\n          if (data[i + 3] === 255) {\n            dataU[offset] = data[i];\n            dataU[offset + 1] = data[i + 1];\n            dataU[offset + 2] = data[i + 2];\n          } else {\n            dataU[offset] = 0;\n            dataU[offset + 1] = 0;\n            dataU[offset + 2] = 0;\n          }\n          offset += bytesPerPixel;\n        }\n      }\n\n      this.reprojData_ = dataR;\n      this.reprojSize_ = [\n        Math.round(targetWidth * this.pixelRatio_),\n        Math.round(targetHeight * this.pixelRatio_),\n      ];\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {\n      return;\n    }\n    this.state = TileState.LOADING;\n    this.changed();\n\n    let leftToLoad = 0;\n\n    this.sourcesListenerKeys_ = [];\n    this.sourceTiles_.forEach((tile) => {\n      const state = tile.getState();\n      if (state !== TileState.IDLE && state !== TileState.LOADING) {\n        return;\n      }\n      leftToLoad++;\n\n      const sourceListenKey = listen(\n        tile,\n        EventType.CHANGE,\n        function () {\n          const state = tile.getState();\n          if (\n            state == TileState.LOADED ||\n            state == TileState.ERROR ||\n            state == TileState.EMPTY\n          ) {\n            unlistenByKey(sourceListenKey);\n            leftToLoad--;\n            if (leftToLoad === 0) {\n              this.unlistenSources_();\n              this.reproject_();\n            }\n          }\n        },\n        this\n      );\n      this.sourcesListenerKeys_.push(sourceListenKey);\n    });\n\n    if (leftToLoad === 0) {\n      setTimeout(this.reproject_.bind(this), 0);\n    } else {\n      this.sourceTiles_.forEach(function (tile) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\nexport default ReprojDataTile;\n", "/**\n * @module ol/resolution\n */\n\n/**\n * @typedef {number|Array<number>} ResolutionLike\n */\n\n/**\n * @param {ResolutionLike} resolution Resolution.\n * @return {number} Resolution.\n */\nexport function fromResolutionLike(resolution) {\n  if (Array.isArray(resolution)) {\n    return Math.min(...resolution);\n  }\n  return resolution;\n}\n"],
  "mappings": "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",
  "names": ["Layer_default", "render", "transform", "source", "state", "Tile_default", "Layer_default", "Tile_default", "dx", "dy", "i", "tileSource", "frameState", "Tile_default", "context", "imageData", "data", "offset", "len", "canvas", "state", "DataTile_default"]
}
